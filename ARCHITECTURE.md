# ðŸ—ï¸ Kiáº¿n trÃºc há»‡ thá»‘ng

## ðŸ“Š SÆ¡ Ä‘á»“ tá»•ng quan

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        CLIENT APPLICATIONS                      â”‚
â”‚                    (Web, Mobile, Desktop)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â”‚ GraphQL Queries/Mutations
                      â”‚ HTTP Requests
                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    GATEWAY SERVICE                              â”‚
â”‚                    Port: 5000                                   â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚              â”‚   Apollo GraphQL        â”‚                       â”‚
â”‚              â”‚   Server + Express      â”‚                       â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                         â”‚                                       â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚    â”‚                    â”‚                    â”‚                 â”‚
â”‚    â–¼                    â–¼                    â–¼                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚ â”‚   AI    â”‚        â”‚  AUTH   â”‚        â”‚  DATA   â”‚             â”‚
â”‚ â”‚Service  â”‚        â”‚Service  â”‚        â”‚Service  â”‚             â”‚
â”‚ â”‚ :5001   â”‚        â”‚ :5003   â”‚        â”‚ :5004   â”‚             â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚    â”‚                    â”‚                    â”‚                 â”‚
â”‚    â–¼                    â–¼                    â–¼                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚ â”‚ MEDIA   â”‚        â”‚   JWT   â”‚        â”‚MongoDB  â”‚             â”‚
â”‚ â”‚Service  â”‚        â”‚ Tokens  â”‚        â”‚+SocketIOâ”‚             â”‚
â”‚ â”‚ :5002   â”‚        â”‚         â”‚        â”‚         â”‚             â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ðŸ”„ Luá»“ng hoáº¡t Ä‘á»™ng chÃ­nh

### 1. Authentication Flow
```
Client â†’ Gateway â†’ Auth Service
â”Œâ”€â”€â”€â”€â”€â”    POST     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    POST     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚User â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚Gateway â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚  Auth   â”‚
â””â”€â”€â”€â”€â”€â”˜  /login     â”‚:5000   â”‚  /login     â”‚Service  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚:5003    â”‚
                          â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚                       â”‚
                          â”‚ JWT Token             â”‚
                          â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚   Client  â”‚
                    â”‚ stores    â”‚
                    â”‚ JWT token â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. GraphQL Query Flow
```
Client â†’ Gateway â†’ Target Service
â”Œâ”€â”€â”€â”€â”€â”   GraphQL   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   HTTP     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚User â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚Gateway â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚Service  â”‚
â””â”€â”€â”€â”€â”€â”˜  Query      â”‚:5000   â”‚  Request   â”‚(AI/Auth â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚/Data/   â”‚
                          â”‚               â”‚Media)   â”‚
                          â”‚ Response      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
                    â”‚   Client  â”‚
                    â”‚ receives  â”‚
                    â”‚   data    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. MCP-lite Communication
```
Gateway â†’ AI Service (MCP Protocol)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   MCP Call   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Gateway â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚AI Serviceâ”‚
â”‚:5000   â”‚ /mcp/call    â”‚:5001    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                         â”‚
     â”‚ Tool Result             â”‚
     â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
â”‚Fallback â”‚
â”‚GraphQL  â”‚
â”‚if MCP   â”‚
â”‚fails    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. Real-time Updates
```
Data Service â†’ Socket.IO â†’ Clients
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    Event     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Data     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  â”‚Socket.IOâ”‚
â”‚Service  â”‚ item_created â”‚ Server  â”‚
â”‚:5004    â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
                               â”‚ Real-time
                               â”‚ Broadcast
                               â–¼
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚   Clients   â”‚
                        â”‚ (Web/Mobile)â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ðŸ› ï¸ CÃ´ng nghá»‡ sá»­ dá»¥ng

| Component | Technology | Purpose |
|-----------|------------|---------|
| **Gateway** | Apollo Server + Express | GraphQL API Gateway |
| **AI Service** | GraphQL + MCP-lite | AI/ML Operations |
| **Auth Service** | JWT + bcrypt | Authentication |
| **Data Service** | MongoDB + Socket.IO | Data Management + Real-time |
| **Media Service** | Express REST API | Media Processing |
| **Communication** | HTTP + MCP-lite | Inter-service communication |
| **Database** | MongoDB (optional) | Data persistence |
| **Cache** | Redis (optional) | Caching layer |

## ðŸ”§ Cáº¥u hÃ¬nh Ports

| Service | Port | Protocol | Endpoints |
|---------|------|----------|-----------|
| Gateway | 5000 | GraphQL | `/graphql`, `/health` |
| AI Service | 5001 | GraphQL + MCP | `/graphql`, `/mcp/tools`, `/mcp/call` |
| Media Service | 5002 | REST | `/health`, `/image/resize` |
| Auth Service | 5003 | REST | `/login`, `/me`, `/health` |
| Data Service | 5004 | REST + Socket.IO | `/items`, `/health` |
| MongoDB | 27017 | Database | - |
| Redis | 6379 | Cache | - |

## ðŸ“‹ Best Practices & Development Rules

### ðŸ—ï¸ Microservices Best Practices

#### 1. Service Design Principles
- **Single Responsibility**: Má»—i service chá»‰ xá»­ lÃ½ má»™t domain cá»¥ thá»ƒ
- **Loose Coupling**: Services khÃ´ng phá»¥ thuá»™c trá»±c tiáº¿p vÃ o nhau
- **High Cohesion**: CÃ¡c chá»©c nÄƒng liÃªn quan Ä‘Æ°á»£c nhÃ³m trong cÃ¹ng service
- **Stateless**: Services khÃ´ng lÆ°u trá»¯ state, sá»­ dá»¥ng external storage

#### 2. Communication Patterns
```typescript
// âœ… GOOD: Async communication vá»›i fallback
const result = await callMcpTool(AI_URL, 'aiHelloTool', { name })
  .catch(() => gqlRequest(AI_URL + '/graphql', query, variables));

// âŒ BAD: Direct service dependency
const result = await aiService.directCall();
```

#### 3. Error Handling
- **Circuit Breaker**: Implement fallback mechanisms
- **Retry Logic**: Exponential backoff cho failed requests
- **Graceful Degradation**: System váº«n hoáº¡t Ä‘á»™ng khi má»™t service fail
- **Health Checks**: Monitor service status vá»›i `/health` endpoints

#### 4. Data Management
- **Database per Service**: Má»—i service cÃ³ database riÃªng
- **Event Sourcing**: Sá»­ dá»¥ng events Ä‘á»ƒ sync data giá»¯a services
- **CQRS**: TÃ¡ch biá»‡t read/write operations khi cáº§n

### ðŸ”§ MCP-lite Protocol Best Practices

#### 1. Tool Naming Convention (Domain-based)
```typescript
// âœ… GOOD: Clear domain-based naming
{
  name: "user.create",
  description: "Create a new user account",
  input: { email: "string", password: "string", name: "string" },
  output: { result: { id: "string", email: "string", name: "string" } }
}

{
  name: "user.update", 
  description: "Update user profile information",
  input: { id: "string", name: "string", email: "string" },
  output: { result: { id: "string", email: "string", name: "string" } }
}

{
  name: "auth.login",
  description: "Authenticate user and return JWT token",
  input: { email: "string", password: "string" },
  output: { result: { token: "string", user: { id: "string", email: "string" } } }
}

// âŒ BAD: Vague, non-domain naming
{
  name: "create",
  description: "Create something",
  input: { data: "any" },
  output: { result: "any" }
}

{
  name: "aiTool",
  description: "AI stuff"
}
```

#### 2. JSON Schema Requirements
```typescript
// âœ… GOOD: Complete JSON Schema vá»›i type/required/properties
const userCreateSchema = {
  type: "object",
  required: ["email", "password", "name"],
  properties: {
    email: {
      type: "string",
      format: "email",
      description: "User email address"
    },
    password: {
      type: "string",
      minLength: 8,
      description: "User password (will be hashed)"
    },
    name: {
      type: "string",
      minLength: 1,
      maxLength: 100,
      description: "User display name"
    }
  },
  additionalProperties: false
};

// âœ… GOOD: Tool registration vá»›i full schema
app.get('/mcp/tools', (req, res) => {
  res.json({
    tools: [
      {
        name: "user.create",
        description: "Create a new user account",
        inputSchema: userCreateSchema,
        outputSchema: {
          type: "object",
          properties: {
            result: {
              type: "object",
              properties: {
                id: { type: "string" },
                email: { type: "string" },
                name: { type: "string" },
                createdAt: { type: "string", format: "date-time" }
              }
            }
          }
        }
      }
    ]
  });
});

// âŒ BAD: Incomplete schema
{
  name: "user.create",
  input: { email: "string", password: "string" }, // Missing validation
  output: { result: "object" } // Too vague
}
```

#### 3. Security Practices

##### Password Handling
```typescript
// âœ… GOOD: Never return password, hash on server
app.post('/mcp/call', async (req, res) => {
  const { tool, input } = req.body;
  
  if (tool === 'user.create') {
    const { email, password, name } = input;
    
    // Hash password on server
    const passwordHash = await bcrypt.hash(password, 12);
    
    // Create user with hashed password
    const user = await User.create({
      email,
      passwordHash, // Store hashed version
      name
    });
    
    // Return only public fields
    res.json({
      result: {
        id: user.id,
        email: user.email,
        name: user.name,
        createdAt: user.createdAt
        // âŒ NEVER return: password, passwordHash
      }
    });
  }
});

// âŒ BAD: Return password or hash
res.json({
  result: {
    id: user.id,
    email: user.email,
    password: user.password, // âŒ NEVER do this
    passwordHash: user.passwordHash // âŒ NEVER do this
  }
});
```

##### Authentication & Authorization
```typescript
// âœ… GOOD: JWT validation for protected tools
const protectedTools = ['user.update', 'user.delete', 'admin.create'];

app.post('/mcp/call', async (req, res) => {
  const { tool, input } = req.body;
  const authHeader = req.headers.authorization;
  
  // Check if tool requires authentication
  if (protectedTools.includes(tool)) {
    if (!authHeader?.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    try {
      const token = authHeader.replace('Bearer ', '');
      const payload = jwt.verify(token, JWT_SECRET) as any;
      
      // Add user context to input
      input.userId = payload.sub;
      input.userRole = payload.role;
      
    } catch (error) {
      return res.status(401).json({ error: 'Invalid token' });
    }
  }
  
  // Role-based authorization
  if (tool === 'admin.create' && input.userRole !== 'admin') {
    return res.status(403).json({ error: 'Admin role required' });
  }
  
  // Process tool...
});
```

#### 4. Error Handling Standards
```typescript
// âœ… GOOD: Standardized error responses
app.post('/mcp/call', async (req, res) => {
  const startTime = Date.now();
  const requestId = req.headers['x-request-id'] || generateRequestId();
  
  try {
    const { tool, input } = req.body;
    
    // Validation errors (4xx)
    if (!tool) {
      return res.status(400).json({ 
        error: 'Tool name is required',
        requestId 
      });
    }
    
    if (!input) {
      return res.status(400).json({ 
        error: 'Input data is required',
        requestId 
      });
    }
    
    // Process tool
    const result = await processTool(tool, input);
    
    // Success response
    res.json({ 
      result,
      requestId,
      processingTime: Date.now() - startTime
    });
    
  } catch (error) {
    // Server errors (5xx)
    console.error('MCP tool error', {
      tool: req.body.tool,
      error: error.message,
      requestId,
      processingTime: Date.now() - startTime
    });
    
    res.status(500).json({ 
      error: 'Internal server error',
      requestId 
    });
  }
});

// âŒ BAD: Inconsistent error format
res.status(400).send('Bad request'); // Missing JSON structure
res.json({ message: 'Error' }); // Wrong field name
```

#### 5. Idempotency
```typescript
// âœ… GOOD: Idempotent operations
app.post('/mcp/call', async (req, res) => {
  const { tool, input } = req.body;
  
  if (tool === 'user.create') {
    const { email, password, name } = input;
    
    // Check if user already exists (idempotent)
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      // Return existing user instead of error
      return res.json({
        result: {
          id: existingUser.id,
          email: existingUser.email,
          name: existingUser.name,
          createdAt: existingUser.createdAt
        },
        message: 'User already exists'
      });
    }
    
    // Create new user
    const user = await User.create({ email, passwordHash: await bcrypt.hash(password, 12), name });
    res.json({ result: { id: user.id, email: user.email, name: user.name } });
  }
  
  if (tool === 'user.update') {
    const { id, email, name } = input;
    
    // Protect against email conflicts
    if (email) {
      const emailExists = await User.findOne({ email, _id: { $ne: id } });
      if (emailExists) {
        return res.status(409).json({ 
          error: 'Email already exists',
          requestId: req.headers['x-request-id']
        });
      }
    }
    
    const user = await User.findByIdAndUpdate(id, { email, name }, { new: true });
    res.json({ result: { id: user.id, email: user.email, name: user.name } });
  }
});
```

#### 6. Observability & Logging
```typescript
// âœ… GOOD: Comprehensive logging vá»›i requestId
app.post('/mcp/call', async (req, res) => {
  const startTime = Date.now();
  const requestId = req.headers['x-request-id'] || generateRequestId();
  const { tool, input } = req.body;
  
  // Log tool call start
  console.log('MCP tool call started', {
    tool,
    requestId,
    timestamp: new Date().toISOString(),
    userAgent: req.headers['user-agent'],
    ip: req.ip
  });
  
  try {
    // Process tool
    const result = await processTool(tool, input);
    const processingTime = Date.now() - startTime;
    
    // Log successful completion
    console.log('MCP tool call completed', {
      tool,
      requestId,
      processingTime,
      status: 'success',
      timestamp: new Date().toISOString()
    });
    
    res.json({ 
      result,
      requestId,
      processingTime
    });
    
  } catch (error) {
    const processingTime = Date.now() - startTime;
    
    // Log error with context
    console.error('MCP tool call failed', {
      tool,
      requestId,
      processingTime,
      error: error.message,
      stack: error.stack,
      input: JSON.stringify(input),
      timestamp: new Date().toISOString()
    });
    
    res.status(500).json({ 
      error: 'Internal server error',
      requestId,
      processingTime
    });
  }
});

// âœ… GOOD: Tool-specific metrics
const toolMetrics = new Map();

const recordToolMetrics = (tool: string, processingTime: number, success: boolean) => {
  if (!toolMetrics.has(tool)) {
    toolMetrics.set(tool, {
      totalCalls: 0,
      totalTime: 0,
      successCount: 0,
      errorCount: 0
    });
  }
  
  const metrics = toolMetrics.get(tool);
  metrics.totalCalls++;
  metrics.totalTime += processingTime;
  
  if (success) {
    metrics.successCount++;
  } else {
    metrics.errorCount++;
  }
};

// âœ… GOOD: Health check vá»›i tool metrics
app.get('/mcp/health', (req, res) => {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    tools: Object.fromEntries(toolMetrics),
    uptime: process.uptime()
  };
  
  res.json(health);
});
```

#### 7. Tool Registration Best Practices
```typescript
// âœ… GOOD: Complete tool registration
const registerTools = () => {
  const tools = [
    {
      name: "user.create",
      description: "Create a new user account",
      version: "1.0.0",
      inputSchema: {
        type: "object",
        required: ["email", "password", "name"],
        properties: {
          email: { type: "string", format: "email" },
          password: { type: "string", minLength: 8 },
          name: { type: "string", minLength: 1, maxLength: 100 }
        }
      },
      outputSchema: {
        type: "object",
        properties: {
          result: {
            type: "object",
            properties: {
              id: { type: "string" },
              email: { type: "string" },
              name: { type: "string" },
              createdAt: { type: "string", format: "date-time" }
            }
          }
        }
      },
      requiresAuth: false,
      rateLimit: { requests: 10, window: "1m" }
    },
    {
      name: "user.update",
      description: "Update user profile information", 
      version: "1.0.0",
      inputSchema: {
        type: "object",
        required: ["id"],
        properties: {
          id: { type: "string" },
          name: { type: "string", minLength: 1, maxLength: 100 },
          email: { type: "string", format: "email" }
        }
      },
      outputSchema: {
        type: "object",
        properties: {
          result: {
            type: "object",
            properties: {
              id: { type: "string" },
              email: { type: "string" },
              name: { type: "string" },
              updatedAt: { type: "string", format: "date-time" }
            }
          }
        }
      },
      requiresAuth: true,
      rateLimit: { requests: 20, window: "1m" }
    }
  ];
  
  return tools;
};

app.get('/mcp/tools', (req, res) => {
  res.json({ tools: registerTools() });
});
```

### ðŸ“‹ MCP Standards Summary

#### âœ… DO's
- **Tool Naming**: Use domain.action format (`user.create`, `auth.login`)
- **JSON Schema**: Complete schemas vá»›i type/required/properties
- **Security**: Never return passwords, hash on server vá»›i bcryptjs
- **Errors**: HTTP 4xx/5xx vá»›i `{ error: "..." }` format
- **Success**: Return `{ result: ... }` format
- **Auth**: Check JWT á»Ÿ `/mcp/call` cho protected tools
- **Idempotency**: Handle duplicate operations gracefully
- **Logging**: Log tool, processing time, requestId
- **Validation**: Validate all input parameters
- **Rate Limiting**: Implement per-tool rate limits

#### âŒ DON'Ts
- **Vague Naming**: Avoid generic names like `create`, `update`
- **Incomplete Schemas**: Don't use `any` types without validation
- **Password Exposure**: Never return password or hash in responses
- **Inconsistent Errors**: Don't mix error response formats
- **Missing Auth**: Don't skip authentication for sensitive operations
- **Non-idempotent**: Don't create duplicates on retry
- **No Logging**: Don't skip observability for debugging
- **No Validation**: Don't trust client input without validation

### ðŸš€ GraphQL Best Practices

#### 1. Schema Design
```graphql
# âœ… GOOD: Clear, descriptive types
type User {
  id: ID!
  email: String!
  profile: UserProfile
  createdAt: DateTime!
}

# âŒ BAD: Vague types
type User {
  id: String
  data: JSON
}
```

#### 2. Resolver Patterns
```typescript
// âœ… GOOD: Error handling vÃ  data validation
const resolvers = {
  Query: {
    me: async (_, __, { req }) => {
      const token = req.headers.authorization?.replace('Bearer ', '');
      if (!token) throw new AuthenticationError('Token required');
      
      try {
        const user = await authService.verifyToken(token);
        return user;
      } catch (error) {
        throw new AuthenticationError('Invalid token');
      }
    }
  }
};
```

#### 3. Performance Optimization
- **DataLoader**: Batch vÃ  cache database queries
- **Field-level Caching**: Cache expensive computations
- **Query Complexity**: Limit query depth vÃ  complexity
- **Pagination**: Implement cursor-based pagination

#### 4. Security
```typescript
// âœ… GOOD: Input validation
const typeDefs = gql`
  type Mutation {
    createItem(name: String!): Item!
  }
`;

// âœ… GOOD: Authorization
const resolvers = {
  Mutation: {
    createItem: async (_, { name }, { user }) => {
      if (!user) throw new AuthenticationError('Must be logged in');
      return await dataService.createItem(name, user.id);
    }
  }
};
```

### ðŸ› ï¸ Development Rules & Conventions

#### 1. Code Organization
```
apps/
â”œâ”€â”€ service-name/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ index.ts          # Main entry point
â”‚   â”‚   â”œâ”€â”€ resolvers/        # GraphQL resolvers
â”‚   â”‚   â”œâ”€â”€ routes/           # REST routes
â”‚   â”‚   â”œâ”€â”€ services/         # Business logic
â”‚   â”‚   â”œâ”€â”€ models/           # Data models
â”‚   â”‚   â””â”€â”€ utils/            # Utilities
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ tsconfig.json
```

#### 2. Environment Configuration
```typescript
// âœ… GOOD: Environment variables vá»›i defaults
const PORT = Number(process.env.PORT || 5000);
const JWT_SECRET = process.env.JWT_SECRET || 'development-secret';
const MONGO_URI = process.env.MONGO_URI || 'mongodb://localhost:27017/app';

// âŒ BAD: Hardcoded values
const PORT = 5000;
const JWT_SECRET = 'secret';
```

#### 3. Logging & Monitoring
```typescript
// âœ… GOOD: Structured logging
console.log('Service started', { 
  service: 'ai-service', 
  port: PORT, 
  env: process.env.NODE_ENV 
});

// âœ… GOOD: Error logging vá»›i context
console.error('MCP call failed', { 
  tool, 
  input, 
  error: error.message,
  timestamp: new Date().toISOString()
});
```

#### 4. Testing Strategy
- **Unit Tests**: Test individual functions vÃ  methods
- **Integration Tests**: Test service interactions
- **Contract Tests**: Test API contracts giá»¯a services
- **End-to-End Tests**: Test complete user workflows

#### 5. Deployment Rules
- **Health Checks**: Implement `/health` endpoints
- **Graceful Shutdown**: Handle SIGTERM signals
- **Resource Limits**: Set memory vÃ  CPU limits
- **Rolling Updates**: Deploy services independently

### ðŸ”’ Security Best Practices

#### 1. Authentication & Authorization
```typescript
// âœ… GOOD: JWT validation
const verifyToken = (token: string) => {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    throw new AuthenticationError('Invalid token');
  }
};

// âœ… GOOD: Role-based access
const requireRole = (role: string) => (req, res, next) => {
  if (!req.user.roles.includes(role)) {
    return res.status(403).json({ error: 'Insufficient permissions' });
  }
  next();
};
```

#### 2. Input Validation
```typescript
// âœ… GOOD: Input sanitization
import { z } from 'zod';

const createItemSchema = z.object({
  name: z.string().min(1).max(100).trim()
});

const { name } = createItemSchema.parse(req.body);
```

#### 3. CORS Configuration
```typescript
// âœ… GOOD: Specific CORS settings
app.use(cors({
  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE']
}));
```

### ðŸ“Š Monitoring & Observability

#### 1. Metrics Collection
- **Response Times**: Monitor API response times
- **Error Rates**: Track error percentages
- **Throughput**: Monitor requests per second
- **Resource Usage**: CPU, memory, disk usage

#### 2. Logging Standards
```typescript
// âœ… GOOD: Structured logging
const logger = {
  info: (message: string, meta?: object) => 
    console.log(JSON.stringify({ level: 'info', message, ...meta })),
  error: (message: string, error?: Error, meta?: object) => 
    console.error(JSON.stringify({ level: 'error', message, error: error?.message, ...meta }))
};
```

#### 3. Health Check Implementation
```typescript
// âœ… GOOD: Comprehensive health checks
app.get('/health', async (req, res) => {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    services: {
      database: await checkDatabase(),
      redis: await checkRedis(),
      external: await checkExternalServices()
    }
  };
  
  const isHealthy = Object.values(health.services).every(status => status === 'healthy');
  res.status(isHealthy ? 200 : 503).json(health);
});
```

### ðŸš€ Performance Guidelines

#### 1. Database Optimization
- **Indexing**: Create proper indexes cho queries
- **Connection Pooling**: Sá»­ dá»¥ng connection pools
- **Query Optimization**: Avoid N+1 queries
- **Caching**: Implement Redis caching cho frequent data

#### 2. API Performance
- **Pagination**: Implement pagination cho large datasets
- **Field Selection**: Chá»‰ return fields cáº§n thiáº¿t
- **Compression**: Enable gzip compression
- **CDN**: Sá»­ dá»¥ng CDN cho static assets

#### 3. Memory Management
- **Streaming**: Sá»­ dá»¥ng streams cho large files
- **Memory Leaks**: Monitor vÃ  fix memory leaks
- **Garbage Collection**: Tune GC settings náº¿u cáº§n
- **Resource Cleanup**: Properly cleanup resources

Nhá»¯ng best practices nÃ y sáº½ giÃºp team phÃ¡t triá»ƒn maintainable, scalable vÃ  secure microservices architecture! ðŸŽ¯
